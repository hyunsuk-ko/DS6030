x = nrow(X.train)
n = 500
holdout_labels = c()
lambdas = c()
linkages = c()
for (i in 1:M) {
ind = sample(x, size = n, replace = FALSE)
holdout = X.train[ind,]
x_train = X.train[-ind,]
y_train = Y.train[-ind]
x_test = holdout
fit.enet = cv.glmnet(x_train, y_train, alpha = alpha, family = "binomial")
lambda = fit.enet$lambda.min
yhat.enet = predict(fit.enet, x_test, s = "lambda.min", type = 'link')
holdout_labels = append(holdout_labels, i)
lambdas = append(lambdas, lambda)
linkages = append(linkages, yhat.enet[,1])
}
linkages
length(linkages)
set.seed(2022)
alpha = .75
M = 1#25
K = 10
x = nrow(X.train)
n = 500
holdout_labels = c()
lambdas = c()
linkages = c()
probs = c()
for (i in 1:M) {
ind = sample(x, size = n, replace = FALSE)
holdout = X.train[ind,]
x_train = X.train[-ind,]
y_train = Y.train[-ind]
x_test = holdout
fit.enet = cv.glmnet(x_train, y_train, alpha = alpha, family = "binomial")
lambda = fit.enet$lambda.min
yhat.enet = predict(fit.enet, x_test, s = "lambda.min", type = 'link')
p.hat = predict(yhat.enet, x_test, type = 'resonse')
holdout_labels = append(holdout_labels, i)
lambdas = append(lambdas, lambda)
linkages = append(linkages, yhat.enet[,1])
probs = append(probs, p.hat)
}
set.seed(2022)
alpha = .75
M = 1#25
K = 10
x = nrow(X.train)
n = 500
holdout_labels = c()
lambdas = c()
linkages = c()
probs = c()
for (i in 1:M) {
ind = sample(x, size = n, replace = FALSE)
holdout = X.train[ind,]
x_train = X.train[-ind,]
y_train = Y.train[-ind]
x_test = holdout
fit.enet = cv.glmnet(x_train, y_train, alpha = alpha, family = "binomial")
lambda = fit.enet$lambda.min
yhat.enet = predict(fit.enet, x_test, s = "lambda.min", type = 'link')
p.hat = predict(fit.enet, x_test, type = 'resonse')
holdout_labels = append(holdout_labels, i)
lambdas = append(lambdas, lambda)
linkages = append(linkages, yhat.enet[,1])
probs = append(probs, p.hat)
}
set.seed(2022)
alpha = .75
M = 1#25
K = 10
x = nrow(X.train)
n = 500
holdout_labels = c()
lambdas = c()
linkages = c()
probs = c()
for (i in 1:M) {
ind = sample(x, size = n, replace = FALSE)
holdout = X.train[ind,]
x_train = X.train[-ind,]
y_train = Y.train[-ind]
x_test = holdout
fit.enet = cv.glmnet(x_train, y_train, alpha = alpha, family = "binomial")
lambda = fit.enet$lambda.min
yhat.enet = predict(fit.enet, x_test, s = "lambda.min", type = 'link')
p.hat = predict(fit.enet, x_test, type = 'response')
holdout_labels = append(holdout_labels, i)
lambdas = append(lambdas, lambda)
linkages = append(linkages, yhat.enet[,1])
probs = append(probs, p.hat)
}
probs
set.seed(2022)
alpha = .75
M = 1#25
K = 10
x = nrow(X.train)
n = 500
holdout_labels = c()
lambdas = c()
linkages = c()
probs = c()
ROC_enet = tibble()
for (i in 1:M) {
ind = sample(x, size = n, replace = FALSE)
holdout = X.train[ind,]
x_train = X.train[-ind,]
y_train = Y.train[-ind]
fit.enet = cv.glmnet(x_train, y_train, alpha = alpha, family = "binomial")
lambda = fit.enet$lambda.min
gamma_enet = predict(fit.enet, X.train, s = "lambda.min", type = 'link')
#yhat.enet = predict(fit.enet, holdout, s = "lambda.min", type = 'link')
holdout_labels = append(holdout_labels, i)
lambdas = append(lambdas, lambda)
linkages = append(linkages, gamma.enet[,1])
#ROC_enet = tibble(truth = factor(Y.train, levels=c(1,0)), gamma = gamma_enet[,1]) %>%
#yardstick::roc_curve(truth, gamma)
ROC_enet = ROC_enet %>% add_row(truth = factor(Y.train, levels=c(1,0)), gamma = gamma_enet[,1])
}
set.seed(2022)
alpha = .75
M = 1#25
K = 10
x = nrow(X.train)
n = 500
holdout_labels = c()
lambdas = c()
linkages = c()
probs = c()
ROC_enet = tibble()
for (i in 1:M) {
ind = sample(x, size = n, replace = FALSE)
holdout = X.train[ind,]
x_train = X.train[-ind,]
y_train = Y.train[-ind]
fit.enet = cv.glmnet(x_train, y_train, alpha = alpha, family = "binomial")
lambda = fit.enet$lambda.min
gamma_enet = predict(fit.enet, X.train, s = "lambda.min", type = 'link')
#yhat.enet = predict(fit.enet, holdout, s = "lambda.min", type = 'link')
holdout_labels = append(holdout_labels, i)
lambdas = append(lambdas, lambda)
linkages = append(linkages, gamma_enet[,1])
#ROC_enet = tibble(truth = factor(Y.train, levels=c(1,0)), gamma = gamma_enet[,1]) %>%
#yardstick::roc_curve(truth, gamma)
ROC_enet = ROC_enet %>% add_row(truth = factor(Y.train, levels=c(1,0)), gamma = gamma_enet[,1])
}
ROC_enet = tibble(truth = NULL, gamma = NULL)
ROC_enet
set.seed(2022)
alpha = .75
M = 1#25
K = 10
x = nrow(X.train)
n = 500
holdout_labels = c()
lambdas = c()
linkages = c()
probs = c()
ROC_enet = tibble(truth = NULL, gamma = NULL)
ROC_enet
for (i in 1:M) {
ind = sample(x, size = n, replace = FALSE)
holdout = X.train[ind,]
x_train = X.train[-ind,]
y_train = Y.train[-ind]
fit.enet = cv.glmnet(x_train, y_train, alpha = alpha, family = "binomial")
lambda = fit.enet$lambda.min
gamma_enet = predict(fit.enet, X.train, s = "lambda.min", type = 'link')
#yhat.enet = predict(fit.enet, holdout, s = "lambda.min", type = 'link')
holdout_labels = append(holdout_labels, i)
lambdas = append(lambdas, lambda)
linkages = append(linkages, gamma_enet[,1])
#ROC_enet = tibble(truth = factor(Y.train, levels=c(1,0)), gamma = gamma_enet[,1]) %>%
#yardstick::roc_curve(truth, gamma)
ROC_enet = ROC_enet %>% add_row(truth = factor(Y.train, levels=c(1,0)), gamma = gamma_enet[,1])
}
set.seed(2022)
alpha = .75
M = 1#25
K = 10
x = nrow(X.train)
n = 500
holdout_labels = c()
lambdas = c()
linkages = c()
truths = c()
gammas = c()
for (i in 1:M) {
ind = sample(x, size = n, replace = FALSE)
holdout = X.train[ind,]
x_train = X.train[-ind,]
y_train = Y.train[-ind]
fit.enet = cv.glmnet(x_train, y_train, alpha = alpha, family = "binomial")
lambda = fit.enet$lambda.min
gamma_enet = predict(fit.enet, X.train, s = "lambda.min", type = 'link')
#yhat.enet = predict(fit.enet, holdout, s = "lambda.min", type = 'link')
holdout_labels = append(holdout_labels, i)
lambdas = append(lambdas, lambda)
linkages = append(linkages, gamma_enet[,1])
#ROC_enet = tibble(truth = factor(Y.train, levels=c(1,0)), gamma = gamma_enet[,1]) %>%
#yardstick::roc_curve(truth, gamma)
truths = append(truths, factor(Y.train, levels=c(1,0)))
gammas = append(gammas, gamma_enet[,1])
}
ROC_enet = tibble(truth = truths, gamma = gammas) %>%
yardstick::roc_curve(truth, gamma)
ROC_enet
ROC_enet %>%
ggplot(aes(1-specificity, sensitivity)) + geom_line() +
geom_abline(lty = 3) +
coord_equal() +
labs(title = "ROC Curve for Elastic Net on Train Data")
source(system.file("config/hw_config.R", package="R6030")) # knitr settings
options(dplyr.summarise.inform = FALSE)  # ignore dplyr message about grouping
data.dir = 'https://mdporter.github.io/DS6030/data/' # data directory
library(R6030)     # functions for SYS-6030
library(tidyverse) # functions for data manipulation
library(glmnet)
library(yardstick)
library(dplyr)
train = read.csv('linkage_train.csv')
test = read.csv('linkage_test.csv')
X = glmnet::makeX(
train = train %>% select(-y),
test = test
)
X.train = X$x
Y.train = train$y
X.test = X$xtest
set.seed(2022)
ridge_cv <- cv.glmnet(X.train, Y.train, alpha = 0, nfolds = 10)
ridge_cv$lambda.min
coef(ridge_cv, s = "lambda.min")
yhat_ridge = predict(ridge_cv, X.test, s = "lambda.min")
set.seed(2022)
fit.enet = cv.glmnet(X.train, Y.train, alpha = 0.5, family = "binomial")
fit.enet$lambda.min
coef(fit.enet, s = "lambda.min")
yhat_enet = predict(fit.enet, X.test, s = "lambda.min")
gamma_ridge = predict(ridge_cv, X.train, s = "lambda.min", type = 'link')
gamma_enet = predict(fit.enet, X.train, s = "lambda.min", type = 'link')
ROC_ridge = tibble(truth = factor(Y.train, levels=c(1,0)), gamma = gamma_ridge[,1]) %>%
yardstick::roc_curve(truth, gamma)
ROC_enet = tibble(truth = factor(Y.train, levels=c(1,0)), gamma = gamma_enet[,1]) %>%
yardstick::roc_curve(truth, gamma)
ROC_ridge %>%
ggplot(aes(1-specificity, sensitivity)) + geom_line() +
geom_abline(lty = 3) +
coord_equal() +
labs(title = "ROC Curve for Ridge Regression on Train Data")
ROC_enet %>%
ggplot(aes(1-specificity, sensitivity)) + geom_line() +
geom_abline(lty = 3) +
coord_equal() +
labs(title = "ROC Curve for Elastic Net on Train Data")
ROC_enet
set.seed(2022)
alpha = .75
M = 1#25
K = 10
x = nrow(X.train)
n = 500
holdout_labels = c()
lambdas = c()
linkages = c()
truths = c()
gammas = c()
for (i in 1:M) {
ind = sample(x, size = n, replace = FALSE)
holdout = X.train[ind,]
x_train = X.train[-ind,]
y_train = Y.train[-ind]
fit.enet = cv.glmnet(x_train, y_train, alpha = alpha, family = "binomial")
lambda = fit.enet$lambda.min
gamma_enet = predict(fit.enet, X.train, s = "lambda.min", type = 'link')
#yhat.enet = predict(fit.enet, holdout, s = "lambda.min", type = 'link')
holdout_labels = append(holdout_labels, i)
lambdas = append(lambdas, lambda)
linkages = append(linkages, gamma_enet[,1])
#ROC_enet = tibble(truth = factor(Y.train, levels=c(1,0)), gamma = gamma_enet[,1]) %>%
#yardstick::roc_curve(truth, gamma)
truths = append(truths, factor(Y.train, levels=c(1,0)))
gammas = append(gammas, gamma_enet[,1])
}
ROC_enet = tibble(truth = truths, gamma = gammas) %>%
yardstick::roc_curve(truth, gamma)
source(system.file("config/hw_config.R", package="R6030")) # knitr settings
options(dplyr.summarise.inform = FALSE)  # ignore dplyr message about grouping
data.dir = 'https://mdporter.github.io/DS6030/data/' # data directory
library(R6030)     # functions for SYS-6030
library(tidyverse) # functions for data manipulation
library(glmnet)
library(yardstick)
library(dplyr)
train = read.csv('linkage_train.csv')
test = read.csv('linkage_test.csv')
X = glmnet::makeX(
train = train %>% select(-y),
test = test
)
X.train = X$x
Y.train = train$y
X.test = X$xtest
set.seed(2022)
ridge_cv <- cv.glmnet(X.train, Y.train, alpha = 0, nfolds = 10)
ridge_cv$lambda.min
coef(ridge_cv, s = "lambda.min")
yhat_ridge = predict(ridge_cv, X.test, s = "lambda.min")
set.seed(2022)
fit.enet = cv.glmnet(X.train, Y.train, alpha = 0.5, family = "binomial")
fit.enet$lambda.min
coef(fit.enet, s = "lambda.min")
yhat_enet = predict(fit.enet, X.test, s = "lambda.min")
gamma_ridge = predict(ridge_cv, X.train, s = "lambda.min", type = 'link')
gamma_enet = predict(fit.enet, X.train, s = "lambda.min", type = 'link')
ROC_ridge = tibble(truth = factor(Y.train, levels=c(1,0)), gamma = gamma_ridge[,1]) %>%
yardstick::roc_curve(truth, gamma)
ROC_enet = tibble(truth = factor(Y.train, levels=c(1,0)), gamma = gamma_enet[,1]) %>%
yardstick::roc_curve(truth, gamma)
ROC_ridge %>%
ggplot(aes(1-specificity, sensitivity)) + geom_line() +
geom_abline(lty = 3) +
coord_equal() +
labs(title = "ROC Curve for Ridge Regression on Train Data")
ROC_enet %>%
ggplot(aes(1-specificity, sensitivity)) + geom_line() +
geom_abline(lty = 3) +
coord_equal() +
labs(title = "ROC Curve for Elastic Net on Train Data")
ROC_enet
set.seed(2022)
alpha = .75
M = 1#25
K = 10
x = nrow(X.train)
n = 500
holdout_labels = c()
lambdas = c()
linkages = c()
truths = c()
gammas = c()
for (i in 1:M) {
ind = sample(x, size = n, replace = FALSE)
holdout = X.train[ind,]
x_train = X.train[-ind,]
y_train = Y.train[-ind]
fit.enet = cv.glmnet(x_train, y_train, alpha = alpha, family = "binomial")
lambda = fit.enet$lambda.min
gamma_enet = predict(fit.enet, X.train, s = "lambda.min", type = 'link')
#yhat.enet = predict(fit.enet, holdout, s = "lambda.min", type = 'link')
holdout_labels = append(holdout_labels, i)
lambdas = append(lambdas, lambda)
linkages = append(linkages, gamma_enet[,1])
#ROC_enet = tibble(truth = factor(Y.train, levels=c(1,0)), gamma = gamma_enet[,1]) %>%
#yardstick::roc_curve(truth, gamma)
truths = append(truths, factor(Y.train, levels=c(1,0)))
gammas = append(gammas, gamma_enet[,1])
}
ROC_enet = tibble(truth = truths, gamma = gammas) %>%
yardstick::roc_curve(truth, gamma)
ROC_enet
ROC_enet %>%
ggplot(aes(1-specificity, sensitivity)) + geom_line() +
geom_abline(lty = 3) +
coord_equal() +
labs(title = "ROC Curve for Elastic Net on Train Data")
ROC_enet
ROC_enet %>%
ggplot(aes(1-specificity, sensitivity)) + geom_line() +
geom_abline(lty = 3) +
coord_equal() +
labs(title = "ROC Curve for Elastic Net on Holdout Data")
linkages
tibble(truth = truths, gamma = gammas)
ROC_tibble = tibble(truth = truths, gamma = gammas)
ROC_enet = ROC_tibble %>%
yardstick::roc_curve(truth, gamma)
ROC_enet
ROC_enet %>%
ggplot(aes(1-specificity, sensitivity)) + geom_line() +
geom_abline(lty = 3) +
coord_equal() +
labs(title = "ROC Curve for Elastic Net on Holdout Data")
table(predicted = ROC_tibble$gamma, truth = ROC_tibble$truth) %>% addmargins()
ROC_enet
ROC_enet %>%
ggplot(aes(1-specificity, sensitivity)) + geom_line() +
geom_abline(lty = 3) +
coord_equal() +
labs(title = "ROC Curve for Elastic Net on Holdout Data")
#table(predicted = ROC_tibble$gamma, truth = ROC_tibble$truth) %>% addmargins()
View(train)
fit.lm = glm(y ~ ., family = 'binomial', data = train)
summary(fit.lm)
fit.lm = glm(y ~ spatial + temporal + tod + dow + LOC + POA + TIMERANGE, family = 'binomial', data = train)
summary(fit.lm)
View(test)
fit.lm = glm(y ~ spatial + temporal + tod + dow + LOC + POA + TIMERANGE, family = 'binomial', data = train)
p.hat = predict(fit.lm, test, type = 'response')
G.hat = ifelse(p.hat >= .1, 1, 0)
G.hat
fit.lm = glm(y ~ spatial + temporal + tod + dow + LOC + POA + TIMERANGE, family = 'binomial', data = train)
p.hat = predict(fit.lm, test, type = 'response')
G.hat = ifelse(p.hat >= .1, 1, 0)
fit.lm = glm(y ~ spatial + temporal + tod + dow + LOC + POA + TIMERANGE, family = 'binomial', data = train)
p.hat = predict(fit.lm, test, type = 'response')
G.hat = ifelse(p.hat >= .1, 1, 0)
my_phat <- data.frame(p = p.hat[,1])
fit.lm = glm(y ~ spatial + temporal + tod + dow + LOC + POA + TIMERANGE, family = 'binomial', data = train)
p.hat = predict(fit.lm, test, type = 'response')
G.hat = ifelse(p.hat >= .1, 1, 0)
my_phat <- data.frame(p = p.hat)
my_phat
write_csv(my_yhat, 'ko_hyunsuk_1.csv')
fit.lm = glm(y ~ spatial + temporal + tod + dow + LOC + POA + TIMERANGE, family = 'binomial', data = train)
p.hat = predict(fit.lm, test, type = 'response')
G.hat = ifelse(p.hat >= .1, 1, 0)
my_phat <- data.frame(p = p.hat)
my_phat
write_csv(my_phat, 'ko_hyunsuk_1.csv')
G.hat = ifelse(p.hat >= .1, 1, 0)
my_ghat <- data.frame(linkage = G.hat)
my_ghat
write_csv(my_ghat, 'ko_hyunsuk_2.csv')
source(system.file("config/hw_config.R", package="R6030")) # knitr settings
options(dplyr.summarise.inform = FALSE)  # ignore dplyr message about grouping
data.dir = 'https://mdporter.github.io/DS6030/data/' # data directory
library(R6030)     # functions for SYS-6030
library(tidyverse) # functions for data manipulation
library(glmnet)
library(yardstick)
library(dplyr)
train = read.csv('linkage_train.csv')
test = read.csv('linkage_test.csv')
X = glmnet::makeX(
train = train %>% select(-y),
test = test
)
X.train = X$x
Y.train = train$y
X.test = X$xtest
set.seed(2022)
ridge_cv <- cv.glmnet(X.train, Y.train, alpha = 0, nfolds = 10)
ridge_cv$lambda.min
coef(ridge_cv, s = "lambda.min")
yhat_ridge = predict(ridge_cv, X.test, s = "lambda.min")
set.seed(2022)
fit.enet = cv.glmnet(X.train, Y.train, alpha = 0.5, family = "binomial")
fit.enet$lambda.min
coef(fit.enet, s = "lambda.min")
yhat_enet = predict(fit.enet, X.test, s = "lambda.min")
gamma_ridge = predict(ridge_cv, X.train, s = "lambda.min", type = 'link')
gamma_enet = predict(fit.enet, X.train, s = "lambda.min", type = 'link')
ROC_ridge = tibble(truth = factor(Y.train, levels=c(1,0)), gamma = gamma_ridge[,1]) %>%
yardstick::roc_curve(truth, gamma)
ROC_enet = tibble(truth = factor(Y.train, levels=c(1,0)), gamma = gamma_enet[,1]) %>%
yardstick::roc_curve(truth, gamma)
ROC_ridge %>%
ggplot(aes(1-specificity, sensitivity)) + geom_line() +
geom_abline(lty = 3) +
coord_equal() +
labs(title = "ROC Curve for Ridge Regression on Train Data")
ROC_enet %>%
ggplot(aes(1-specificity, sensitivity)) + geom_line() +
geom_abline(lty = 3) +
coord_equal() +
labs(title = "ROC Curve for Elastic Net on Train Data")
ROC_enet
set.seed(2022)
alpha = .75
M = 1#25
K = 10
x = nrow(X.train)
n = 500
holdout_labels = c()
lambdas = c()
linkages = c()
truths = c()
gammas = c()
for (i in 1:M) {
ind = sample(x, size = n, replace = FALSE)
holdout = X.train[ind,]
x_train = X.train[-ind,]
y_train = Y.train[-ind]
fit.enet = cv.glmnet(x_train, y_train, alpha = alpha, family = "binomial")
lambda = fit.enet$lambda.min
gamma_enet = predict(fit.enet, X.train, s = "lambda.min", type = 'link')
holdout_labels = append(holdout_labels, i)
lambdas = append(lambdas, lambda)
linkages = append(linkages, gamma_enet[,1])
truths = append(truths, factor(Y.train, levels=c(1,0)))
gammas = append(gammas, gamma_enet[,1])
}
ROC_tibble = tibble(truth = truths, gamma = gammas)
ROC_enet = ROC_tibble %>%
yardstick::roc_curve(truth, gamma)
ROC_enet
ROC_enet %>%
ggplot(aes(1-specificity, sensitivity)) + geom_line() +
geom_abline(lty = 3) +
coord_equal() +
labs(title = "ROC Curve for Elastic Net on Holdout Data")
#table(predicted = ROC_tibble$gamma, truth = ROC_tibble$truth) %>% addmargins()
fit.lm = glm(y ~ spatial + temporal + tod + dow + LOC + POA + TIMERANGE, family = 'binomial', data = train)
p.hat = predict(fit.lm, test, type = 'response')
my_phat <- data.frame(p = p.hat)
my_phat
write_csv(my_phat, 'ko_hyunsuk_1.csv')
